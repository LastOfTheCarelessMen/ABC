#!/usr/bin/env perl6

use v6;
use ABC::Header;
use ABC::Tune;
use ABC::Grammar;
use ABC::Actions;
use ABC::Duration; #OK
use ABC::Note;
use ABC::LongRest;
use ABC::Utils;
use ABC::KeyInfo;
use ABC::Context;
use ABC::ToLilypond;

my $paper-size = "letter"; # or switch to "a4" for European paper

sub TunesToLilypondStream(@tunes, $out, :$fancy?) {
    $out.say: '\\version "2.12.3"';
    $out.say: "#(set-default-paper-size \"{$paper-size}\")";
    if $fancy {
        $out.say: Q:to/END/;
            \paper { 
                print-all-headers = ##t
                top-margin = 1\in
                left-margin = 1\in
                right-margin = 1\in
                indent = 0
                tagline = #ff
            }
        END
    } else {
        $out.say: "\\paper \{ print-all-headers = ##t \}";
    }
    
    for @tunes -> $tune {
        $*ERR.say: "Working on { $tune.header.get-first-value("T") // $tune.header.get-first-value("X") }";
        $out.say: "\\score \{";

            TuneBodyToLilypondStream($tune, $out);
            HeaderToLilypond($tune.header, $out);

        $out.say: "}\n\n";
        
        if $tune.header.get-first-value("N") {
            $out.say: "\\markuplist \{";
            $out.say: "    \\wordwrap-lines \{";
            for $tune.header.get("N") -> $note {
                if $note.value ~~ / ^ \s* $ / {
                    $out.say: '    } \wordwrap-lines {';
                } else {
                    my $text = $note.value;
                    # this is some goofy magic to make sure quotation marks come out correctly.
                    $text .= subst(/ (\S*) '"' (\S*)/, 
                                   {
                                       my $prefix = $0;
                                       my $postfix = $1;
                                       $prefix .= subst('"', '" \\char #34 "', :global);
                                       "\\concat \{ \"$prefix\" \\char #34 \"$postfix\" \} "
                                   }, 
                                   :global);
                    $out.say: "        $text";
                }
            }
            $out.say: '    }';
            $out.say: "    \\vspace #2";
            $out.say: "}\n\n";
        }
    }
}

sub TuneStreamToTunes($in) {
    my $actions = ABC::Actions.new;
    my $match = ABC::Grammar.parse($in.slurp-rest, :rule<tune_file>, :$actions);
    die "Did not match ABC grammar: last tune understood:\n { $actions.current-tune }" unless $match;
    @( $match.ast );
}

sub TuneStreamToLilypondStream($in, $out, $filter = *, :$fancy?) {
    my @tunes = TuneStreamToTunes($in);
    TunesToLilypondStream(@tunes.grep($filter), $out, :$fancy);
}

# This is from https://rosettacode.org/wiki/Longest_common_prefix#Perl_6
# Bit wonky looking but seems to work!
sub longest-common-prefix(@s) { 
    substr @s[0], 0, [+] [\and] [Zeqv] |@sÂ».ords 
}

sub TunesStreamToScore($in, $out) {
    my $actions = ABC::Actions.new;
    my $match = ABC::Grammar.parse($in.slurp-rest, :rule<tune_file>, :$actions);
    die "Did not match ABC grammar: last tune understood:\n { $actions.current-tune }" unless $match;
    my @tunes = @( $match.ast );

    my @names = @tunes.map({ $_.header.get-first-value("T") });
    my $name = longest-common-prefix(@names).trim;
    dd $name;
    @names .= map(-> $full-name { $full-name.substr($name.chars).trim });
    dd @names;

    $out.say: '\\version "2.12.3"';
    $out.say: "#(set-default-paper-size \"{$paper-size}\")";
    $out.say: "\\paper \{ print-all-headers = ##t \}";

    $out.say: "\\score \{";
    $out.say: '<<';

    for @tunes Z, @names -> ($tune, $name) {
        dd $name;
        $*ERR.say: "Working on { $tune.header.get-first-value("T") // $tune.header.get-first-value("X") }";

        $out.say: "\\new Staff ";
        TuneBodyToLilypondStream($tune, $out, prefix => qq[\\set Staff.instrumentName = "$name"]);
    }

    $out.say: '>>';
    HeaderToLilypond(@tunes[0].header, $out, title => $name);
    $out.say: "}\n\n";
}

multi sub MAIN() {
    TuneStreamToLilypondStream($*IN, $*OUT);
}

multi sub MAIN($first-abc-file, *@other-abc-files, :x($index)?, :$o?, :$mc?, :$fancy?, :$score?) {
    my @abc-files = $first-abc-file, |@other-abc-files;
    for @abc-files -> $abc-file {
        my $ly-file;
        if $o {
            $ly-file = $o;
        } else {
            $ly-file = $abc-file ~ ".ly";
            if $abc-file ~~ /^(.*) ".abc"/ {
                $ly-file = $0 ~ ".ly";
            }
        }
        $*ERR.say: "Reading $abc-file, writing $ly-file";
    
        my $in = open $abc-file, :r or die "Unable to open $abc-file";
        my $out = open $ly-file, :w or die "Unable to open $ly-file";
    
        if $score {
            TunesStreamToScore($in, $out);
        } elsif $index {
            TuneStreamToLilypondStream($in, $out, -> $tune { $tune.header.get-first-value("X") == $index }, :$fancy);
        } else {
            TuneStreamToLilypondStream($in, $out, :$fancy);
        }
    
        if $mc {
            $out.say: '\markup {';
            $out.say: '    \fill-line { "For more information on these tunes, please see http://midlandceltic.org/ws2011/" }';
            $out.say: '}';
        }
    
        $out.close;
        $in.close;
        
        qqx/lilypond $ly-file/;
    }
    
    $*ERR.say: "Unrecognized gracings: " ~ GetUnrecognizedGracings().keys.join(", ") if GetUnrecognizedGracings();
}

# multi sub MAIN($abc-file, :$split, :$fancy?) {
#     my $in = open $abc-file, :r or die "Unable to open $abc-file";
#     my @tunes = TuneStreamToTunes($in);
#
#     for @tunes -> $tune {
#         my $title = $_.header.get-first-value("T");
# #        TunesToLilypondStream([$tune], $out, :$fancy);
#     }
#
#     $*ERR.say: "Unrecognized gracings: " ~ %unrecognized_gracings.keys.join(", ") if %unrecognized_gracings;
# }

